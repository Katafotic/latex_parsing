\section{Correctness proof of Algorithms~\ref{alg:findisointersection}, \ref{alg:getautomorphisms} and \ref{alg:getsingleisomorphism}}

\todo[inline]{rewrite \& check if all references to algorithm contents are still correct}

Here, we prove that \findisomorphismsetintersection~is correct, for which we need the following remark and lemma.

\begin{remark}
    \label{remark:correctness-isomorphism-intersection}
    If $I$ is an \isomorphismset, then denote by $\pi_I$ the single isomorphism and by $G_I$ the \automorphismgenerators~object it contains.
    Furthermore, denote by $\langle G\rangle$ the automorphism group generated by $G$.
    Upon input $I_A, I_B$ and output $I$, the correctness criterion of the function \findisomorphismsetintersection~is equivalent to 
    \[
        \pi_{I} \cdot \langle G \rangle = \left( \pi_{I_A} \cdot \langle G_{I_A} \rangle \right) \cap \left( \pi_{I_B} \cdot \langle G_{I_B} \rangle \right)
    \]
    where we have denoted $\pi \cdot G = \{\pi \cdot g \mid g \in G\}$.
\end{remark}


\begin{lemma}
    \label{thm:coset-intersection-nonempty}
    Let $G$ be a group with subgroups $G_A$ and $G_B$, and let $\pi_A, \pi_B \in G$.
    The intersection $(\pi_A \cdot G_A)\cap (\pi_B \cdot G_B)$ is nonempty if and only if $\pi_A^{-1} \pi_B$ can be written as $\pi_A^{-1}\pi_B=g_A \cdot g_B$, for some $g_A \in G_A$ and $g_B \in G_B$.
\end{lemma}
\begin{proof}
    \todo[inline]{fill (with proof that Lieuwe wrote before)}
\end{proof}

Now we prove that the algorithm \findisomorphismsetintersection~is correct.

\begin{lemma}
    The function \findisomorphismsetintersection~satisfies its correctness criterion given in 
    \cref{remark:correctness-isomorphism-intersection}.
\end{lemma}
\begin{proof}
    First, we start by using the well-known fact that the intersection of two cosets $\pi_{I_A} \cdot \langle G_{I_A} \rangle$ and $\pi_{I_B} \cdot \langle G_{I_B} \rangle$ is either empty, or it is a coset of $\langle G_{I_A} \rangle \cap \langle G_{I_B} \rangle$.
    Hence, the algorithm is correct if 
    \begin{enumerate}[(a)]
        \item the \automorphismgenerators~object it outputs is $\langle G_{I_A} \rangle \cap \langle G_{I_B} \rangle$;
        \item the single isormorphism it outputs is an element of $\left( \pi_{I_A} \cdot \langle G_{I_A} \rangle \right) \cap \left( \pi_{I_B} \cdot \langle G_{I_B} \rangle \right)$, or \none~if this intersection is empty.
    \end{enumerate}

    We first prove (a).
    The central insight is that the removal of elements containing $X$ or $Y$ from $H_B^{\textnormal{echelon}}$ in step 7 does not alter the intersection we aim for. That is:
    \begin{equation}
        \label{eq:noXY}
    \langle H_A \rangle \cap \langle H_B^{\textnormal{echelon}} \rangle = 
    \langle H_A \rangle \cap \langle H^{\textnormal{noXY}}_B \rangle
        .
    \end{equation}
    The reason why this holds is that elements of $H_A$ do not contain $X$ or $Y$, while for each $k \in \{1, 2, \dots n\}$, there is at most a single operator in $H_B^{\textnormal{echelon}}$ which contains a pivot at position $k$ which is either $X$ or $Y$; therefore, no element in $\langle H_A\rangle \cap \langle H_B^{\textnormal{echelon}}\rangle$ will have a decomposition in $H_B^{\textnormal{echelon}}$ containing operators containing $X$ or $Y$.
    \todo[inline]{argument is simpler than I manage to put into words; add picture to clarify the argument?}

    Let us now prove the (a).
    We use the notation $U^{\dagger} A U = \{U^{\dagger} a U | a \in A\}$ where $A$ is an arbitrary set.
    Following the notation from the algorithm,
    \begin{eqnarray*}
        \langle G\rangle
        &=&
        U^{\dagger} \left(
        \langle H_A \rangle \cap \langle H_B^{\textnormal{noXY}}\rangle
        \right) U
        \\
        &\stackrel{\textnormal{eq.~\eqref{eq:noXY}}}{=}&
        U^{\dagger} \left(
        \langle H_A \rangle \cap \langle H_B^{\textnormal{echelon}}\rangle
        \right) U
        \\
        &=&
        U^{\dagger} \left(
        \langle H_A \rangle \cap \langle H_B\rangle
        \right) U
        \\
        &=&
        U^{\dagger} \left(
        \langle U G_A U^{\dagger} \rangle \cap \langle U G_B U^{\dagger}\rangle
        \right) U
        \\
        &\stackrel{*}{=}&
        U^{\dagger} U \left(
        \langle G_A \rangle \cap \langle G_B\rangle
        \right) U^{\dagger} U
        \\
        &=&
        \langle G_A \rangle \cap \langle G_B\rangle
    \end{eqnarray*}
    where $\stackrel{*}{=}$ holds because the map $x \mapsto Ux U^{\dagger}$ is a group isomorphism.

    We prove (b) by showing the following two statements: (b1) if the single isomorphism that is outputted by the isomorphism is not \none, then it is an element of the intersection of $\pi_{I_A} \cdot \langle G_{I_A} \rangle$ and $\pi_{I_B} \cdot \langle G_{I_B} \rangle$, and (b2) if the outputted isomorphism is $\none$, then this intersection is empty.

    Proving (b1) is straightforward: from step 8 of the algorithm we see that 
    \begin{equation}
        \label{eq:tau-prime-1}
   \tau' = \prod_{j} h_j^A \cdot \prod_{k} h_k^B
    \end{equation}
    where $h_j^A \in H_A, h_k^B\in H_{B}^{\textnormal{noXY}}$
    while from steps 1--5 we observe that $\tau'$ can also be written as
    \begin{equation}
        \label{eq:tau-prime-2}
        \tau' = U\pi_A^{-1} U^{\dagger} U \pi_B U^{\dagger} \cdot \prod_{\ell} h_{\ell}^{\textnormal{echelon}}
    \end{equation}
 for $h_{\ell}^{\textnormal{echelon}} \in \langle H_B^{\textnormal{echelon}} \rangle = \langle H_B \rangle$.
    Combining eqs.~\eqref{eq:tau-prime-1} and~\eqref{eq:tau-prime-2} and reshuffling yields
    \begin{equation}
        \label{eq:tau-prime-3}
        U \pi_B U^{\dagger} \cdot \prod_{\ell} h_{\ell}^{\textnormal{echelon}}  \cdot \prod_{k} \left(h_k^B\right)^{-1}
        =
        U\pi_A U^{\dagger} \cdot \prod_{j} h_j^A
    \end{equation}
    Applying the group isomorphism $x \mapsto U^{\dagger} x U$ to both sides of eq.~\eqref{eq:tau-prime-3}, we find
    \[
        \pi_B \cdot \prod_{\ell} U^{\dagger} h_{\ell}^{\textnormal{echelon}} U  \cdot \prod_{k} U^{\dagger} \left(h_k^B\right)^{-1} U
        =
        \pi_A \cdot \prod_{j} U^{\dagger} h_j^A U
    \]
    Since $H_A = \{UgU^{\dagger} | g \in G_A\}$ and similary for $H_B$ we infer that
    \[
        \pi_A \cdot \prod_{j} U^{\dagger} h_j^A U \in 
    \]
    is an element of
    both
    $\pi_{I_A} \cdot \langle G_{I_A} \rangle$
    and
    $\pi_{I_B} \cdot \langle G_{I_B} \rangle$
    , which proves (b1).

    For proving (b2), we note that the algorithm outputs \none~precisely if $\tau'$ cannot be written as $h_A \cdot h_B$ where $h_{\Box} \in \langle H_{\Box} \rangle$.
    To see this, consider the two steps in the algorithm where \none~is returned:
    \begin{itemize}
        \item in step 6; $\tau'$ contains at least one $X$ or $Y$ which has not been eliminated in step 5, while $H_A$ only contains $Z$ and $\unit_2$, so $\tau'\notin \langle H_A \rangle \cdot \langle H_B \rangle$.\todo[inline]{maybe needs more rigorous proof}
        \item in step 8, where the Zassenheim algorithm finds a decomposition of $\tau'$ of the form $h_A \cdot h_B$ only if it exists.
    \end{itemize}
It follows from the fact that $\tau'$ is not an element of $\langle H_A \rangle \cdot \langle H_B \rangle$ that $\tau$ is neither, and using the fact that $x\mapsto UxU^{\dagger}$ is a group isomorphism, we find by definition of $\tau$ that $\pi_A^{-1} \pi_B \notin \langle G_A \rangle \cdot \langle G_B\rangle$.
    It now follows from Lemma~\ref{thm:coset-intersection-nonempty} that the intersection between $\pi_A\cdot \langle G_A \rangle$ and $\pi_B\cdot \langle G_B \rangle$ is empty, which concludes the proof for (b2).
\end{proof}





\begin{lemma}[Conditional correctness of function \getautomorphisms]
    \label{lemma:condition-correctness-1}
    The function \getautomorphisms~satisfies its correctness criterions for single-qubit states.
    Moreover, it also does so for $n$-qubit states for $n>1$, conditioned on the correctness of the function \getsingleisomorphism~for quantum states on strictly fewer than $n$ qubits.
\end{lemma}
\begin{proof}
    In case two states are given as input, then the correctness of the algorithm is an immediate consequence of the correctness of the single-state-input case and the correctness of the algorithm \findautomorphismsetintersection.
    So we only need to prove the case where a single state is given as input.
    We use induction on the number of qubits $n$.
    The case $n=1$ is a brute-force search over the (six) single-qubit stabilizer states and is thus correct.
    For the case $n>1$, we show the following two statements:

    (i) each operator that is outputted by \getautomorphisms~is an automorphism of $\ket{\phi}$;

    (ii) each automorphism of $\ket{\phi}$ can be written as product of operators outputted by \getautomorphisms.

    Showing (i) is straightforward, assuming that \getsingleisomorphism~and \getautomorphisms~are both correct for $(n-1)$-qubit states.
    For example, for the operators of the form $\unit_2\otimes g$ with $g$ an automorphism to both $\ket{\phi_0}$ and $\ket{\phi_1}$, we write
    \begin{eqnarray*}
        \unit_2 \otimes g \ket{\phi}
        =
        \alpha_0 \ket{0} \otimes g\ket{\phi_0} + \alpha_1 \ket{1} \otimes g\ket{\phi_1}
        =
        \alpha_0 \ket{0} \otimes \ket{\phi_0} + \alpha_1 \ket{1} \otimes \ket{\phi_1}
        = \ket{\phi}
        .
    \end{eqnarray*}
    The other three cases are similar.

    Regarding (ii), we first note that if $\unit_2 \otimes g$ is an automorphism of $\ket{\phi}$, then $
    \alpha_0 \ket{\phi_0} =
    \left(\bra{0}\otimes \unit_{2^{n-1}}\right) \left(\unit_2 \otimes g \ket{\phi}\right) =
    g (\alpha_0 \ket{\phi_0})
    $
    and hence $g$ must be an automorphism to $\ket{\phi_0}$, while following a similar argument $g$ is also an automorphism to $\ket{\phi_1}$.
    This shows that all automorphisms of the form $\unit_2 \otimes g$ are in the output of \getautomorphisms.
    Regarding automorphisms of the form $X\otimes a$ with $a$ an $(n-1)$ qubit Pauli operator, it is not hard to see that $a$ is an isomorphism mapping $\alpha_0 \ket{\phi_0}$ to $\alpha_1 \ket{\phi_1}$ and vice versa.
    Now note that $X\otimes a = (X\otimes s)(\unit_2 \otimes s a)$ where $s$ is as in the algorithm.
    Since $s$ maps $\alpha_0 \ket{\phi_0}$ to $\alpha_1 \ket{\phi_1}$, we see that $sa$ is an automorphism to both $\ket{\phi_0}$ and $\ket{\phi_1}$, so that $X\otimes a$ can be written as product of elements outputted by \getautomorphisms.
    The argument for the remaining two cases, i.e. automorphisms of the form $Z\otimes a$ and $Y\otimes a$, are similar.
    This finishes the proof for (ii).
\end{proof}


\begin{lemma}[Conditional correctness of function \getsingleisomorphism]
    \label{lemma:condition-correctness-2}
    The function \getsingleisomorphism~satisfies its correctness criterions for $0$-qubit states.
    Moreover, it also does so for $n$-qubit states for $n>0$, conditioned on the correctness of the function \getautomorphisms~for quantum states on strictly fewer than $n$ qubits.
    \todo[inline]{Readers might $0$-qubit states find confusing...Reason we chose it is because starting the recursion at 0 qubits gives a concise formulation than at 1 qubit}
\end{lemma}
\begin{proof}
    If the input are $0$-qubit states, then correctness is immediate, both for single- and two-tuple input.
    For the case of $n$-qubit input states with $n>0$, correctness of the two-tuple case follows immediately from the correctness of the functions \getautomorphisms~(on $n$ qubits) and \findisomorphismsetintersection.
    The case $n>0$ for the single-tuple input case is also correct since the algorithm is a brute-force search over the four single-qubit Pauli operators on the most-significant qubit.
\end{proof}

By induction on the number of qubits, the correctness of the algorithm \getsingleisomorphism~now follows straighforwardly from Lemma~\ref{lemma:condition-correctness-1} and \ref{lemma:condition-correctness-2}.

\begin{corollary}[Unconditional correctness of function \getsingleisomorphism]
    The function \getsingleisomorphism~satisfies its correctness criterions.
\end{corollary}



\section{Correctness proof of \textsc{GetCanonicalLabels}}
\label{sec:proof-getcanonicallabels}

\todo[inline]{TODO}


\begin{lemma}
    \label{lemma:automorphism-phase}
    If $\lambda P$ is an element of a Pauli automorphism group, then $\lambda \in \{\pm 1\}$.
\end{lemma}
\begin{proof}
    Let $\lambda P$ be an element of the automorphism group of a state $\ket{\phi}$.
    Then $\lambda^2 \ket{\phi} = (\lambda P)^2 \ket{\phi} = \lambda P (\lambda P \ket{\phi}) = \lambda P \ket{\phi} = \ket{\phi}$, so $\lambda^2 = 1$, so $\lambda \in \{\pm 1\}$.
\end{proof}

\begin{lemma}
    Let $G_0, G_1$ be Pauli automorphism groups and $G = \langle G_0 \cup G_1 \rangle$.
    If $g\in G$, then $\pm i g \notin G$.
\end{lemma}
\begin{proof}
    To reach a contradiction, assume there exists a $g\in G$ for which $\pm i g \in G$ also.
    Since Pauli LIMs commute or anticommute, we can decompose both as $g = (-1)^x g_0 g_1$ and $\pm i g = (-1)^y h_0 h_1$ for some $x, y \in \{0, 1\}$ and $g_0, h_0\in G_0$ and $g_1, h_1 \in G_1$.
    Combining yields $\pm i (-1)^x g_0 g_1 = (-1)^y h_0 h_1$, which we rewrite as $\pm i (-1)^{x+y} \underbrace{g_1 h_1^{-1}}_{\in G_1} = \underbrace{g_0^{-1} h_0}_{\in G_0}$. 
    Squaring both sides yields the contradiction $-1 \cdot \id[2] = \id[2]$ where we used that automorphisms square to $\id[2]$ (corollary of \autoref{lemma:automorphism-phase}).
\end{proof}

\begin{corollary}
    Let $G_0, G_1$ be Pauli automorphism groups and $G = \langle G_0 \cup G_1 \rangle$.
    If $\lambda P \in G$ and $\mu P \in G$, then $\lambda = \pm \mu$.
\end{corollary}
